# Chatper 2 고계 자바스크립트

## Why JavaScript?
NodeJS가 나온 이후로 자바스크립트는 웹, 모바일, 서버, 데스크톱, 임베디드 등에서 사용이 가능합니다.

JavaScript는 정말로 응용 분야가 정말로 많습니다.

## 함수형 대 객체지향 프로그래밍 
함수형 객체지향 프로그래밍 둘다 중대형 시스템에 개발에 사용 가능 하고, Scala와 F#과 같은 하이브리드 형 언어는 이 두 페러다임을 잘 섞어 두었습니다. 

함수형 프로그래밍이라고 객체지향을 배제하는 형태가 아닌 이 둘을 모으면 강향한 어플리케이션을 구축할수 있습니다.

허나 이 둘의 선을 어디에 그어야 하는지는 개발자의 개인적인 취양과 문제의 요건에 따라 달라집니다. 


## 2.3 함수

함수형 프로그래밍에서 함수는 작업의 기본 단위 힙니다. 함수는 () 연사자를 적용하여 평가할수 있는 모든 호출 가능한 표현식을 가리키며 호출자에게 계산한값또는 VOID함수라면 undefined를 변환 합니다.

함수형 프로그래밍에서는 수학책에 나오는 함수 처럼 값이 변환되는(null 이나 undefined가 아닌)에만 의마가 있습니다. 

표현식(값을 반환하는) 과 구문(값을 내지 않는 함수) 두용어로 구분합니다.

### 함수를 일급 시민으로 

자바스크립트에서 함수는 실젤 객체 이기 때문에 first class 입니다.

```js
function multiplier(a, b){
    return a*b;
}

```
위와 같은 선언은 많이 보았습니다. 허나 아래와 같이 표헌할 수 있습니다.

```js
const suqare = function(x) {
    return x * x;
}
const suqare = (x) => x*x;
const suqare = (x) => {return x*x};

```
또한 객체 속성으로 함수를 할당 할 수 있습니다.

```js
const obj = {
    method: function(x) {
        return x*x;
    },
    doMore: (x) => x*x,
}
```
많이 쓰이는 방식은 아니지만(저도 처음암) 생성자을 통해 함수를 인스턴스화 하는 방식도 있습니다.

```js
const multipiler = new Function('a', 'b', 'return a * b');
multipiler(2, 3); // 6
```
자바스크립트에서는 모든 함수가 Function 타입의 인스턴스 입니다. 

함수의 length는 인자의 갯수를 나타냄니다. 

apply와 call 메소드는 함수를 주어진 콘텍스트로 호출 합니다.

sort처럼 값을 할당 할수 있으면서 다른 함수를 인자로 받을 수 있으므로 고계 함수에 속함니다.



## 2.4 클로저와 스코프
자바스크립트가 나오기 전에는 클로저는 순수히 FP언어에만 존제하였고, 특정 어플리케이션에서 제한적으로만 사용되었습니다.

또한 자바스크립트에서 개발요소로 클로저를 채택한 후로 많은 변화를 가져왔습니다.

``` js
function zipCose(code, location){
    let _code = code;
    let _location = location || "";
    return {
        code: function() {
            return _code;
        }.
        location: function (){
            return _location;
        }
    }
}
```
zipCode 함수가 변환한 객체 리터럴이 함수 스코프 밖에 선언된 변수에 접근하여 사용할 수 있습니다. 즉 zipCode 실행 이후에도 자신을 감산 함수에 선언되었던 정보를 계속 바라볼 수 있습니다.

```js
const printCode = zipcode("08544", "3345");
printCode.code(); // 08544
```
얼핏보면 private method를 모방하고 서버에서 데이터를 조회하고 블록 스코프에 변수를 묶어 둘때 클로저를 사용할 수 있습니다.

클로저는 함수를 선언할 당시의 환경에 함수를 묶어둔 자료구조 입니다. 함수 선언부의 물리적위치에 의존 하므로 정적 스코프 혹은 어휘 스코프라고도 합니다.

클로저를 사용하면 명확하고 가독성 높은 코트 처리 및 콜백, 프라이베이트 변수 모방 그리고 자바스크립트의 일부 약점을 보완하는 용도로도 유익 합니다.

클로저는 자바스크립트의 스코핑 규칙과 많은 관련이 있습니다. 스코프는 열련의 변수 바인딩을 한데 모아 변수가 정의된 코드 역역을 확정하는데, 사실상 클로저는 함수의 스코프를 상속한것입니다. 자신의 부모 레퍼런스를 가리킨다는 점에서 객체의 메서드가 자신이 상속한 인스턴스 변수에 접근하는 방법이나 마찬가지 입니다.

```js
function makeAddFunction(amount){
    function add(number) {
        return amount + number;
    }
    return add;
}

function makeExponentialFunction(base){
    function raise(expornent) {
        return Math.pow(base, expornent);
    }
    return raise;
}
let addTenTo = makeAddFunction(10);
addTenTo(10); // 20

let raiseThreeTo = makeExponentialFunction(3);
raiseThreeTo(2); // 9
```
위 예제에서는 두 함수의 amount, base는 더 이상 활성 스코프에 없지만 변환 된 함수를 호출하면 계속 호출 할수 있습니다. 중첨된 두 함수가 자신을 둘러싼 모든 변수의 스냅샷을 간직하고 있기 떄문입니다.

부모 함수에서 return 하기전 모든 변수 함수를 다 간직합니다.

뭔가 redux에서 store였던가.... makeExponentialFunction(3)(2); 요런식으로 호출을 가끔식 했던 기억이 있는데 그 이유가 이것....

### 전역 스코프의 문제점
전역 스코프는 가장 단순하면서 가장 나쁜 스코프 입니다. 전역 스코프에는 어느 함수에도 속하지 않은 객체 및 변수가 자리하고 이들은 모든 자바스크립트 코드가 자유롭게 접근 할 수 있습니다. 

함수형 프로그래밍에서는 관찰 가능한 어떤 변화도 함수에서 전파되는것을 금기시 하는데 전역 스크프에선 한줄 한줄이 그런 변화를 일으키는 원인이 됨니다. 

전역 변수가 페이지에 적재된 모든 스크립트가 공유 하기 때문에 모듈단위로 잘 묶지 않는다면 namespace끼리 출동 할수 있씁니다.

프론트에서 모든 js 스코프가 모두 함처지는 것을 이야기 합니다. t.js에서 a라는변수를 선언하고 한페이지에서 g.js를 호출하고 a라는 변수를 가져오면 가져올 수 있습니다.

함수 내에서 가능하면 선언을 하고 함수 내에서 선언된 변수는 함수 내에서만 사용

### 자바스크립트의 함수 스코프 
함수 스코프는 자바스크립트가 선호하는 스코프 방식입니다. 함수 내부에 선언된 변수는 해당 함수의 지역 변수라서 다른 곳에서는 보이지 않고 함수가 변환되는 순간 할당이 해제 됨니다.

x라는 변수를 요청시 -> 함수 스코프(innerScope) 확인 -> 부모 스코프(outterScope) 확인 -> 전역 스코프(globalScope) 확인 -> undefined

```js
function dowork(){
    if(조건) {
        var value = 10;
    }
    console.log(value); // 10
}
dowork();
```

### 의사 블록 스코프
es5 표준 자바스크립트에서는 if, switch. for, while, 처럼 제어 구조를 중괄호로 감싼 블록 수준의 스코프를 지원하지 않습니다. catch는 예외

`var`는 `function`에 스코프가 할당되기 때문에 블록 단위로 선언을 하고 싶다면 es6에서 추가된 `let`을 사용하여 선언해야합니다. 또한 `const` 역시 블록 단위로 선언이 가능합니다.


### 클로저 응용 

프라이베이스 변수를 모방이 가능합니다.

클로저는 전역 범위의 데이터 공유를 피하기 위해 전역 namespace 관리 수단으로도 사용 됨니다.

실제로 모듈 개발자는 전체 모듈의 프라이베잇 메소드와 데이터를 숨길때 클로저를 적극 활용합니다.( 사실 이 방법 말곤 없음)

이것을 모듈 패던이라고 합니다.

또한 즉시 실행함수 IIFE를 사용해서 즉시 실행합니다.


서버측 비동기 호출

솔직히 이건 PROMISE나 async/await를 사용하면 더 편리하게 사용이 가능합니다.


가상의 블록 스코프 변수를 생성

foreach를 클로저로 호출하면 매 루프 마다 가상의 스코프를 만들어 비동기코드에서 변수가 모든 루프가 끝나 i가 루프 끝을 가리키는 문제를 해결 할 수 있습니다.
